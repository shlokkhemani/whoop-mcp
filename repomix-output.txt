This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
config.env.example
README.md
requirements.txt
run.sh
setup.sh
whoop_mcp_server.py
whoop_oauth_server.py

================================================================
Files
================================================================

================
File: .gitignore
================
# Virtual Environment
venv/
env/
.env

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Token storage
whoop_tokens.json

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

================
File: config.env.example
================
# WHOOP OAuth Configuration
# Copy this file to .env and fill in your actual values

WHOOP_CLIENT_ID=your_client_id_here
WHOOP_CLIENT_SECRET=your_client_secret_here

================
File: README.md
================
# WHOOP OAuth Server

A Python Flask server that handles the complete WHOOP OAuth 2.0 flow and stores authenticated user bearer tokens locally.

## Features

- Complete OAuth 2.0 authorization flow
- Automatic token exchange and storage
- Token refresh functionality
- Web interface for easy interaction
- Local token storage in JSON format
- API testing capabilities

## Setup

### Quick Setup (Recommended)

```bash
# Run the setup script
./setup.sh

# Edit your credentials
nano .env  # or use your preferred editor

# Start the server
./run.sh
```

### Manual Setup

#### 1. Create Virtual Environment

```bash
python3 -m venv venv
source venv/bin/activate
```

#### 2. Install Dependencies

```bash
pip install -r requirements.txt
```

#### 3. Configure Client Credentials

You need to obtain your WHOOP client credentials from the WHOOP Developer Portal:

1. Go to [developer.whoop.com](https://developer.whoop.com)
2. Create a new application
3. Set redirect URI to: `http://localhost:5000/callback`
4. Note your `client_id` and `client_secret`

#### 4. Set Environment Variables

Create a `.env` file in the project directory:

```bash
cp config.env.example .env
```

Then edit `.env` with your actual credentials:

```
WHOOP_CLIENT_ID=your_actual_client_id
WHOOP_CLIENT_SECRET=your_actual_client_secret
```

## Usage

### Using Scripts (Recommended)

```bash
# Start the server
./run.sh
```

### Manual Start

```bash
# Activate virtual environment
source venv/bin/activate

# Start the server
python whoop_oauth_server.py
```

The server will start at `http://localhost:8080`

### OAuth Flow

1. **Open the web interface**: Navigate to `http://localhost:8080`
2. **Start authentication**: Click "Start WHOOP Authentication"
3. **Authorize**: You'll be redirected to WHOOP's authorization page
4. **Login and consent**: Log in to your WHOOP account and grant permissions
5. **Automatic callback**: The server will handle the callback and store your tokens

### API Endpoints

- `GET /` - Main web interface
- `GET /authorize` - Start OAuth flow
- `GET /callback` - OAuth callback handler (automatic)
- `GET /tokens` - View stored tokens (JSON)
- `POST /refresh_token` - Refresh access token
- `POST /test_api` - Test API call with current token
- `POST /clear_tokens` - Clear stored tokens

### Using the Stored Tokens

Tokens are stored in `whoop_tokens.json` in the project directory. The file contains:

```json
{
  "access_token": "eyJhbGciOi...",
  "token_type": "bearer",
  "expires_in": 3600,
  "refresh_token": "def50200...",
  "scope": "offline read:profile read:sleep ...",
  "expires_at": "2024-01-01T12:00:00"
}
```

### Making API Calls

You can use the stored access token to make API calls to WHOOP:

```python
import requests
import json

# Load tokens
with open('whoop_tokens.json', 'r') as f:
    tokens = json.load(f)

# Make API call
headers = {'Authorization': f"Bearer {tokens['access_token']}"}
response = requests.get('https://api.prod.whoop.com/developer/v2/user/profile/basic', headers=headers)
print(response.json())
```

## OAuth Scopes

The server requests the following scopes:
- `offline` - Allows refresh token usage
- `read:profile` - Read user profile information
- `read:body_measurement` - Read body measurement data
- `read:cycles` - Read recovery and strain cycles
- `read:sleep` - Read sleep data
- `read:workout` - Read workout data

## Security Notes

- Tokens are stored locally in plain text JSON
- The server runs on localhost only by default
- State parameter is used for CSRF protection
- Tokens include expiration information

## Troubleshooting

### Common Issues

1. **"Client credentials not configured"**
   - Make sure you've set `WHOOP_CLIENT_ID` and `WHOOP_CLIENT_SECRET`
   - Check that your `.env` file is in the correct location

2. **"OAuth error" during authorization**
   - Verify your redirect URI matches exactly: `http://localhost:5000/callback`
   - Check that your client credentials are correct

3. **"Failed to exchange code for tokens"**
   - Ensure your client secret is correct
   - Check that the authorization code hasn't expired

4. **"API call failed"**
   - Your access token may have expired - try refreshing
   - Verify the token has the required scopes

### Debug Mode

The server runs in debug mode by default. For production use, set `debug=False` in the `app.run()` call.

## Example WHOOP API Calls

Once you have a valid access token, you can make calls to various WHOOP API endpoints:

```python
# User profile
GET https://api.prod.whoop.com/developer/v2/user/profile/basic

# Sleep data
GET https://api.prod.whoop.com/developer/v2/activity/sleep

# Workout data  
GET https://api.prod.whoop.com/developer/v2/activity/workout

# Recovery data
GET https://api.prod.whoop.com/developer/v2/cycle/recovery
```

All requests require the `Authorization: Bearer YOUR_ACCESS_TOKEN` header.

================
File: requirements.txt
================
Flask==2.3.3
requests==2.31.0
python-dotenv==1.0.0

================
File: run.sh
================
#!/bin/bash

# WHOOP OAuth Server Run Script
echo "üöÄ Starting WHOOP OAuth Server..."

# Check if virtual environment exists
if [ ! -d "venv" ]; then
    echo "‚ùå Virtual environment not found. Please run ./setup.sh first."
    exit 1
fi

# Activate virtual environment
echo "üîß Activating virtual environment..."
source venv/bin/activate

# Check if .env file exists
if [ ! -f ".env" ]; then
    echo "‚ö†Ô∏è  .env file not found. Please run ./setup.sh first."
    exit 1
fi

# Start the server
echo "üåê Starting server at http://localhost:8080"
echo "Press Ctrl+C to stop the server"
echo ""
python whoop_oauth_server.py

================
File: setup.sh
================
#!/bin/bash

# WHOOP OAuth Server Setup Script
echo "üöÄ Setting up WHOOP OAuth Server with virtual environment..."

# Create virtual environment if it doesn't exist
if [ ! -d "venv" ]; then
    echo "üì¶ Creating virtual environment..."
    python3 -m venv venv
fi

# Activate virtual environment
echo "üîß Activating virtual environment..."
source venv/bin/activate

# Upgrade pip
echo "‚¨ÜÔ∏è  Upgrading pip..."
pip install --upgrade pip

# Install dependencies
echo "üìö Installing dependencies..."
pip install -r requirements.txt

# Create .env file if it doesn't exist
if [ ! -f ".env" ]; then
    echo "‚öôÔ∏è  Creating .env file from template..."
    cp config.env.example .env
    echo "üìù Please edit .env file with your WHOOP credentials:"
    echo "   - WHOOP_CLIENT_ID=your_client_id_here"
    echo "   - WHOOP_CLIENT_SECRET=your_client_secret_here"
fi

echo ""
echo "‚úÖ Setup complete!"
echo ""
echo "Next steps:"
echo "1. Edit .env file with your WHOOP credentials"
echo "2. Run: source venv/bin/activate"
echo "3. Run: python whoop_oauth_server.py"
echo ""
echo "The server will be available at: http://localhost:5000"

================
File: whoop_mcp_server.py
================
"""WHOOP MCP server with balanced daily insights and flexible querying.

Provides both quick daily readiness checks and detailed historical analysis.
"""

from __future__ import annotations

import os
from typing import Any, Literal, Annotated
from datetime import datetime, timedelta, timezone

import httpx
from pydantic import Field

from fastmcp import FastMCP
from fastmcp.server.dependencies import get_http_request

WHOOP_BASE = os.getenv("WHOOP_API_BASE", "https://api.prod.whoop.com/developer")


class WhoopClient:
    """Lightweight HTTP client wrapper for WHOOP API calls."""

    def __init__(self, access_token: str, timeout_s: float = 30.0) -> None:
        self._client = httpx.AsyncClient(
            base_url=WHOOP_BASE,
            timeout=timeout_s,
            headers={"Authorization": f"Bearer {access_token}"},
        )

    async def get(self, path: str, params: dict[str, Any] | None = None) -> dict[str, Any]:
        query: dict[str, Any] = {}
        if params:
            query.update(params)
        if "next_token" in query and query["next_token"] is not None:
            query["nextToken"] = query.pop("next_token")

        response = await self._client.get(path, params=query)
        if response.status_code == 429:
            reset = response.headers.get("X-RateLimit-Reset")
            raise RuntimeError(
                f"WHOOP rate limit hit; retry after {reset or 'a short delay'} seconds",
            )
        response.raise_for_status()
        if response.content and "application/json" in response.headers.get("content-type", ""):
            return response.json()
        return {}

    async def aclose(self) -> None:
        await self._client.aclose()


def _resolve_bearer_token() -> str:
    request = get_http_request()
    auth_header = request.headers.get("authorization")
    if not auth_header:
        raise RuntimeError("Authorization header missing from request.")
    return auth_header.split(" ", 1)[1]


mcp = FastMCP(
    name="whoop-mcp",
    instructions=(
        "WHOOP raw data bundles and activity queries. "
        "All timestamps are UTC; convert in the client based on the user's timezone. "
        "Use get_daily_update for a daily update and get_activities for windowed records."
    ),
)


async def _dispatch_get(path: str, params: dict[str, Any] | None = None) -> dict[str, Any]:
    token = _resolve_bearer_token()
    client = WhoopClient(token)
    try:
        return await client.get(path, params=params)
    finally:
        await client.aclose()


# ---------- Utility functions ----------
def _iso(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def _days_ago(days: int) -> str:
    """Return ISO timestamp for N days ago from now."""
    dt = datetime.now(timezone.utc) - timedelta(days=days)
    return _iso(dt)


def _start_of_day(days_ago: int = 0) -> str:
    """Return ISO timestamp for start of day (UTC midnight) N days ago."""
    dt = datetime.now(timezone.utc) - timedelta(days=days_ago)
    start = datetime(dt.year, dt.month, dt.day, 0, 0, 0, tzinfo=timezone.utc)
    return _iso(start)


async def _collect_all(path: str, params: dict[str, Any], max_pages: int = 10) -> list[dict[str, Any]]:
    """Collect all paginated results up to max_pages."""
    records: list[dict[str, Any]] = []
    next_token: str | None = None
    for _ in range(max_pages):
        qp = dict(params)
        if next_token:
            qp["next_token"] = next_token
        data = await _dispatch_get(path, qp)
        records.extend(data.get("records", []))
        next_token = data.get("next_token")
        if not next_token:
            break
    return records


# ---------- Main Tools ----------

@mcp.tool
async def get_daily_update() -> dict[str, Any]:
    """Return raw records for latest recovery, last completed sleep, recent cycles, and today's workouts (UTC)."""
    
    # Get latest recovery
    now = _iso(datetime.now(timezone.utc))
    recovery_data = await _dispatch_get("/v2/recovery", {"limit": 1, "end": now})
    recovery = (recovery_data.get("records") or [{}])[0]
    
    # Get last completed sleep
    sleep_data = await _dispatch_get("/v2/activity/sleep", {"limit": 1, "end": now})
    sleep = (sleep_data.get("records") or [{}])[0]
    
    # Get recent cycles (last 2 days)
    cycles_start = _days_ago(2)
    cycles_data = await _dispatch_get("/v2/cycle", {"start": cycles_start, "end": now, "limit": 10})
    cycles = cycles_data.get("records", [])
    
    # Get today's workouts
    today_start = _start_of_day(0)
    workouts_data = await _dispatch_get("/v2/activity/workout", {"start": today_start, "end": now, "limit": 10})
    workouts = workouts_data.get("records", [])
    
    return {
        "recovery": recovery,
        "sleep": sleep,
        "recent_cycles": cycles,
        "today_workouts": workouts,
        "window": {
            "today_start": today_start,
            "now": now,
            "cycles_start": cycles_start
        }
    }


@mcp.tool
async def get_activities(
    activity_type: Annotated[
        Literal["all", "sleep", "workouts", "recovery", "cycles"],
        Field(description="Type of activity to retrieve")
    ] = "all",
    days_back: Annotated[
        int | None,
        Field(description="Number of days to look back (default: 7)")
    ] = 7,
    start_date: Annotated[
        str | None,
        Field(description="ISO date string for custom start (overrides days_back)")
    ] = None,
    end_date: Annotated[
        str | None,
        Field(description="ISO date string for custom end (default: now)")
    ] = None
) -> dict[str, Any]:
    """Query any WHOOP data over flexible time periods.
    
    Use days_back for relative queries or start_date/end_date for specific periods."""
    
    # Determine time window
    if start_date:
        start = start_date if "T" in start_date else f"{start_date}T00:00:00Z"
    else:
        start = _days_ago(days_back or 7)
    
    if end_date:
        end = end_date if "T" in end_date else f"{end_date}T23:59:59Z"
    else:
        end = _iso(datetime.now(timezone.utc))
    
    result: dict[str, Any] = {
        "window": {"start": start, "end": end}
    }
    
    # Fetch requested data
    if activity_type in ("all", "sleep"):
        sleeps = await _collect_all("/v2/activity/sleep", {"start": start, "end": end, "limit": 25})
        result["sleep"] = sleeps
    
    if activity_type in ("all", "workouts"):
        workouts = await _collect_all("/v2/activity/workout", {"start": start, "end": end, "limit": 25})
        result["workouts"] = workouts
    
    if activity_type in ("all", "recovery"):
        recoveries = await _collect_all("/v2/recovery", {"start": start, "end": end, "limit": 25})
        result["recovery"] = recoveries
    
    if activity_type in ("all", "cycles"):
        cycles = await _collect_all("/v2/cycle", {"start": start, "end": end, "limit": 25})
        result["cycles"] = cycles
    
    return result


@mcp.tool
async def get_trends(
    period: Annotated[
        Literal["week", "month"],
        Field(description="Period to analyze")
    ] = "week"
) -> dict[str, Any]:
    """Analyze trends by comparing current period metrics to previous period.
    
    Returns raw data for both periods to enable trend analysis."""
    
    now = datetime.now(timezone.utc)
    
    if period == "week":
        # Current week (Monday to now)
        days_since_monday = now.weekday()
        current_start = _start_of_day(days_since_monday)
        current_end = _iso(now)
        
        # Previous week (same days)
        prev_start = _start_of_day(days_since_monday + 7)
        prev_end = _days_ago(7)
    else:  # month
        # Current month so far
        current_start = f"{now.year}-{now.month:02d}-01T00:00:00Z"
        current_end = _iso(now)
        
        # Same days of previous month
        prev_month = now.month - 1 if now.month > 1 else 12
        prev_year = now.year if now.month > 1 else now.year - 1
        prev_start = f"{prev_year}-{prev_month:02d}-01T00:00:00Z"
        prev_end = f"{prev_year}-{prev_month:02d}-{now.day:02d}T23:59:59Z"
    
    # Fetch data for both periods
    current_recovery = await _collect_all("/v2/recovery", {"start": current_start, "end": current_end, "limit": 25})
    current_sleep = await _collect_all("/v2/activity/sleep", {"start": current_start, "end": current_end, "limit": 25})
    current_cycles = await _collect_all("/v2/cycle", {"start": current_start, "end": current_end, "limit": 25})
    current_workouts = await _collect_all("/v2/activity/workout", {"start": current_start, "end": current_end, "limit": 25})
    
    previous_recovery = await _collect_all("/v2/recovery", {"start": prev_start, "end": prev_end, "limit": 25})
    previous_sleep = await _collect_all("/v2/activity/sleep", {"start": prev_start, "end": prev_end, "limit": 25})
    previous_cycles = await _collect_all("/v2/cycle", {"start": prev_start, "end": prev_end, "limit": 25})
    previous_workouts = await _collect_all("/v2/activity/workout", {"start": prev_start, "end": prev_end, "limit": 25})
    
    return {
        "period": period,
        "current": {
            "window": {"start": current_start, "end": current_end},
            "recovery": current_recovery,
            "sleep": current_sleep,
            "cycles": current_cycles,
            "workouts": current_workouts
        },
        "previous": {
            "window": {"start": prev_start, "end": prev_end},
            "recovery": previous_recovery,
            "sleep": previous_sleep,
            "cycles": previous_cycles,
            "workouts": previous_workouts
        }
    }


if __name__ == "__main__":
    mcp.run(transport="http", host="0.0.0.0", port=int(os.getenv("PORT", "9000")))

================
File: whoop_oauth_server.py
================
#!/usr/bin/env python3
"""
WHOOP OAuth Server
A Flask server that handles the complete WHOOP OAuth 2.0 flow and stores bearer tokens locally.
"""

import os
import json
import secrets
import urllib.parse
import requests
from flask import Flask, request, redirect, render_template_string, jsonify
from datetime import datetime, timedelta
import base64
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

app = Flask(__name__)

# Configuration
WHOOP_BASE_URL = "https://api.prod.whoop.com"
REDIRECT_URI = "http://localhost:8080/callback"
SCOPES = "offline read:profile read:body_measurement read:cycles read:sleep read:workout"

# Load configuration from environment or config file
CLIENT_ID = os.getenv('WHOOP_CLIENT_ID')
CLIENT_SECRET = os.getenv('WHOOP_CLIENT_SECRET')

# Token storage file
TOKENS_FILE = "whoop_tokens.json"

# HTML template for the web interface
HTML_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>WHOOP OAuth Server</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .container { background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .info { background: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; }
        button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .token-display { background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; word-break: break-all; }
        .config-section { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 4px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>WHOOP OAuth Server</h1>
    
    {% if not client_configured %}
    <div class="config-section">
        <h3>‚ö†Ô∏è Configuration Required</h3>
        <p>Please set your WHOOP client credentials:</p>
        <ul>
            <li><strong>WHOOP_CLIENT_ID</strong> - Your WHOOP app's client ID</li>
            <li><strong>WHOOP_CLIENT_SECRET</strong> - Your WHOOP app's client secret</li>
        </ul>
        <p>You can set these as environment variables or create a .env file.</p>
    </div>
    {% endif %}
    
    {% if client_configured %}
    <div class="container">
        <h3>OAuth Flow Status</h3>
        {% if tokens %}
        <div class="success">
            <h4>‚úÖ Authentication Successful!</h4>
            <p><strong>Access Token:</strong></p>
            <div class="token-display">{{ tokens.access_token[:50] }}...</div>
            <p><strong>Expires:</strong> {{ tokens.expires_at }}</p>
            <p><strong>Scopes:</strong> {{ tokens.scope }}</p>
            <form method="post" action="/refresh_token" style="display: inline;">
                <button type="submit">üîÑ Refresh Token</button>
            </form>
            <form method="post" action="/test_api" style="display: inline; margin-left: 10px;">
                <button type="submit">üß™ Test API Call</button>
            </form>
        </div>
        {% else %}
        <div class="info">
            <h4>Ready to Authenticate</h4>
            <p>Click the button below to start the WHOOP OAuth flow.</p>
            <form method="get" action="/authorize">
                <button type="submit">üîê Start WHOOP Authentication</button>
            </form>
        </div>
        {% endif %}
    </div>
    
    <div class="container">
        <h3>API Endpoints</h3>
        <ul>
            <li><strong>GET /authorize</strong> - Start OAuth flow</li>
            <li><strong>GET /callback</strong> - OAuth callback handler</li>
            <li><strong>GET /tokens</strong> - View stored tokens</li>
            <li><strong>POST /refresh_token</strong> - Refresh access token</li>
            <li><strong>POST /test_api</strong> - Test API call with current token</li>
        </ul>
    </div>
    {% endif %}
</body>
</html>
"""

class TokenManager:
    """Manages WHOOP tokens storage and retrieval."""
    
    def __init__(self, tokens_file=TOKENS_FILE):
        self.tokens_file = tokens_file
    
    def save_tokens(self, token_data):
        """Save tokens to local file."""
        try:
            with open(self.tokens_file, 'w') as f:
                json.dump(token_data, f, indent=2)
            return True
        except Exception as e:
            print(f"Error saving tokens: {e}")
            return False
    
    def load_tokens(self):
        """Load tokens from local file."""
        try:
            if os.path.exists(self.tokens_file):
                with open(self.tokens_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            print(f"Error loading tokens: {e}")
        return None
    
    def clear_tokens(self):
        """Clear stored tokens."""
        try:
            if os.path.exists(self.tokens_file):
                os.remove(self.tokens_file)
            return True
        except Exception as e:
            print(f"Error clearing tokens: {e}")
            return False

token_manager = TokenManager()

@app.route('/')
def index():
    """Main page showing OAuth status."""
    tokens = token_manager.load_tokens()
    client_configured = bool(CLIENT_ID and CLIENT_SECRET)
    return render_template_string(HTML_TEMPLATE, tokens=tokens, client_configured=client_configured)

@app.route('/authorize')
def authorize():
    """Start the OAuth authorization flow."""
    if not CLIENT_ID or not CLIENT_SECRET:
        return jsonify({"error": "Client credentials not configured"}), 400
    
    # Generate random state for CSRF protection
    state = secrets.token_urlsafe(8)
    
    # Build authorization URL
    auth_params = {
        'response_type': 'code',
        'client_id': CLIENT_ID,
        'redirect_uri': REDIRECT_URI,
        'scope': SCOPES,
        'state': state
    }
    
    auth_url = f"{WHOOP_BASE_URL}/oauth/oauth2/auth?" + urllib.parse.urlencode(auth_params)
    
    # Store state in session (in production, use proper session management)
    app.config['SECRET_KEY'] = secrets.token_hex(16)
    
    return redirect(auth_url)

@app.route('/callback')
def callback():
    """Handle OAuth callback."""
    code = request.args.get('code')
    state = request.args.get('state')
    error = request.args.get('error')
    
    if error:
        return jsonify({"error": f"OAuth error: {error}"}), 400
    
    if not code:
        return jsonify({"error": "No authorization code received"}), 400
    
    # Exchange code for tokens
    token_data = exchange_code_for_tokens(code)
    
    if token_data:
        # Calculate expiration time
        expires_in = token_data.get('expires_in', 3600)
        expires_at = datetime.now() + timedelta(seconds=expires_in)
        token_data['expires_at'] = expires_at.isoformat()
        
        # Save tokens
        if token_manager.save_tokens(token_data):
            return redirect('/?success=true')
        else:
            return jsonify({"error": "Failed to save tokens"}), 500
    else:
        return jsonify({"error": "Failed to exchange code for tokens"}), 400

def exchange_code_for_tokens(code):
    """Exchange authorization code for access and refresh tokens."""
    token_url = f"{WHOOP_BASE_URL}/oauth/oauth2/token"
    
    data = {
        'grant_type': 'authorization_code',
        'code': code,
        'redirect_uri': REDIRECT_URI,
        'client_id': CLIENT_ID,
        'client_secret': CLIENT_SECRET
    }
    
    try:
        response = requests.post(token_url, data=data, headers={
            'Content-Type': 'application/x-www-form-urlencoded'
        })
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Token exchange failed: {response.status_code} - {response.text}")
            return None
            
    except Exception as e:
        print(f"Error exchanging code for tokens: {e}")
        return None

@app.route('/tokens')
def get_tokens():
    """Get stored tokens."""
    tokens = token_manager.load_tokens()
    if tokens:
        # Don't expose the full token in JSON response for security
        safe_tokens = tokens.copy()
        if 'access_token' in safe_tokens:
            safe_tokens['access_token'] = safe_tokens['access_token'][:20] + "..."
        if 'refresh_token' in safe_tokens:
            safe_tokens['refresh_token'] = safe_tokens['refresh_token'][:20] + "..."
        return jsonify(safe_tokens)
    else:
        return jsonify({"message": "No tokens found"})

@app.route('/refresh_token', methods=['POST'])
def refresh_token():
    """Refresh the access token using the refresh token."""
    tokens = token_manager.load_tokens()
    
    if not tokens or 'refresh_token' not in tokens:
        return jsonify({"error": "No refresh token available"}), 400
    
    refresh_url = f"{WHOOP_BASE_URL}/oauth/oauth2/token"
    
    data = {
        'grant_type': 'refresh_token',
        'refresh_token': tokens['refresh_token'],
        'client_id': CLIENT_ID,
        'client_secret': CLIENT_SECRET
    }
    
    try:
        response = requests.post(refresh_url, data=data, headers={
            'Content-Type': 'application/x-www-form-urlencoded'
        })
        
        if response.status_code == 200:
            new_tokens = response.json()
            # Calculate new expiration time
            expires_in = new_tokens.get('expires_in', 3600)
            expires_at = datetime.now() + timedelta(seconds=expires_in)
            new_tokens['expires_at'] = expires_at.isoformat()
            
            # Save updated tokens
            if token_manager.save_tokens(new_tokens):
                return redirect('/?refreshed=true')
            else:
                return jsonify({"error": "Failed to save refreshed tokens"}), 500
        else:
            return jsonify({"error": f"Token refresh failed: {response.status_code} - {response.text}"}), 400
            
    except Exception as e:
        return jsonify({"error": f"Error refreshing token: {e}"}), 500

@app.route('/test_api', methods=['POST'])
def test_api():
    """Test API call with current access token."""
    tokens = token_manager.load_tokens()
    
    if not tokens or 'access_token' not in tokens:
        return jsonify({"error": "No access token available"}), 400
    
    # Test with user profile endpoint
    profile_url = f"{WHOOP_BASE_URL}/developer/v2/user/profile/basic"
    
    headers = {
        'Authorization': f"Bearer {tokens['access_token']}"
    }
    
    try:
        response = requests.get(profile_url, headers=headers)
        
        if response.status_code == 200:
            return jsonify({
                "success": True,
                "data": response.json(),
                "status_code": response.status_code
            })
        else:
            return jsonify({
                "error": f"API call failed: {response.status_code}",
                "response": response.text
            }), 400
            
    except Exception as e:
        return jsonify({"error": f"Error making API call: {e}"}), 500

@app.route('/clear_tokens', methods=['POST'])
def clear_tokens():
    """Clear stored tokens."""
    if token_manager.clear_tokens():
        return redirect('/?cleared=true')
    else:
        return jsonify({"error": "Failed to clear tokens"}), 500

if __name__ == '__main__':
    print("WHOOP OAuth Server")
    print("==================")
    print(f"Server will run at: http://localhost:8080")
    print(f"Redirect URI: {REDIRECT_URI}")
    print()
    
    if not CLIENT_ID or not CLIENT_SECRET:
        print("‚ö†Ô∏è  WARNING: Client credentials not configured!")
        print("Set WHOOP_CLIENT_ID and WHOOP_CLIENT_SECRET environment variables")
        print("or create a .env file with these values.")
        print()
    
    print("Starting server...")
    app.run(debug=True, host='0.0.0.0', port=8080)



================================================================
End of Codebase
================================================================
